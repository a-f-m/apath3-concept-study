//=========================================================================
//
//  This file was generated by Mouse 1.8 at 2018-05-15 18:48:17 GMT
//  from grammar
//    'C:\Work\Daten\Documents\Development\Eclipse-ng-sem\Eclipse-private\A
//    path3\src\main\java\hidden\parserV3.peg'.
//
//=========================================================================

package org.afm.apath3.parsing;

import mouse.runtime.Source;

public class PathPegParserV3 extends mouse.runtime.ParserBase
{
  final afm.mouse.DefaultSemantics sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public PathPegParserV3()
    {
      sem = new afm.mouse.DefaultSemantics();
      sem.rule = this;
      super.sem = sem;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      boolean result = Start();
      closeParser(result);
      return result;
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public afm.mouse.DefaultSemantics semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  Start = __ expr? __ !_ {T} ~{error} ;
  //=====================================================================
  public boolean Start()
    {
      begin("Start");
      if (Start_0())
      { sem.T(); return accept(); }
      sem.error();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  Start_0 = __ expr? __ !_
  //-------------------------------------------------------------------
  public boolean Start_0()
    {
      begin("");
      __();
      expr();
      __();
      if (!aheadNot()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  rule = (name ":" __)? expr ("-->" __ "json" __ "<<" __ ("\>>" /
  //    !">>" _)* __ ">>")? ;
  //=====================================================================
  public boolean rule()
    {
      begin("rule");
      rule_0();
      if (!expr()) return reject();
      rule_1();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  rule_0 = name ":" __
  //-------------------------------------------------------------------
  public boolean rule_0()
    {
      begin("");
      if (!name()) return rejectInner();
      if (!next(':')) return rejectInner();
      __();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  rule_1 = "-->" __ "json" __ "<<" __ ("\>>" / !">>" _)* __ ">>"
  //-------------------------------------------------------------------
  public boolean rule_1()
    {
      begin("");
      if (!next("-->")) return rejectInner();
      __();
      if (!next("json")) return rejectInner();
      __();
      if (!next("<<")) return rejectInner();
      __();
      while (rule_2());
      __();
      if (!next(">>")) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  rule_2 = "\>>" / !">>" _
  //-------------------------------------------------------------------
  public boolean rule_2()
    {
      begin("");
      if (next("\\>>")) return acceptInner();
      if (rule_3()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  rule_3 = !">>" _
  //-------------------------------------------------------------------
  public boolean rule_3()
    {
      begin("");
      if (!aheadNot(">>")) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  expr = ifExpr {TL} ;
  //=====================================================================
  public boolean expr()
    {
      begin("expr");
      if (!ifExpr()) return reject();
      sem.TL();
      return accept();
    }
  
  //=====================================================================
  //  ifExpr = ("if" NLOD __ boolOrExpr "then" NLOD __ expr ("else" NLOD
  //    __ expr)? / boolOrExpr) {TL} ;
  //=====================================================================
  public boolean ifExpr()
    {
      begin("ifExpr");
      if (!ifExpr_0()
       && !boolOrExpr()
         ) return reject();
      sem.TL();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ifExpr_0 = "if" NLOD __ boolOrExpr "then" NLOD __ expr ("else"
  //    NLOD __ expr)?
  //-------------------------------------------------------------------
  public boolean ifExpr_0()
    {
      begin("");
      if (!next("if")) return rejectInner();
      if (!NLOD()) return rejectInner();
      __();
      if (!boolOrExpr()) return rejectInner();
      if (!next("then")) return rejectInner();
      if (!NLOD()) return rejectInner();
      __();
      if (!expr()) return rejectInner();
      ifExpr_1();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ifExpr_1 = "else" NLOD __ expr
  //-------------------------------------------------------------------
  public boolean ifExpr_1()
    {
      begin("");
      if (!next("else")) return rejectInner();
      if (!NLOD()) return rejectInner();
      __();
      if (!expr()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  boolOrExpr = boolAndExpr (boolOrOp boolAndExpr)* {TL} ;
  //=====================================================================
  public boolean boolOrExpr()
    {
      begin("boolOrExpr");
      if (!boolAndExpr()) return reject();
      while (boolOrExpr_0());
      sem.TL();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  boolOrExpr_0 = boolOrOp boolAndExpr
  //-------------------------------------------------------------------
  public boolean boolOrExpr_0()
    {
      begin("");
      if (!boolOrOp()) return rejectInner();
      if (!boolAndExpr()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  boolOrOp = ("or" NLOD / "||") __ {C} ;
  //=====================================================================
  public boolean boolOrOp()
    {
      begin("boolOrOp");
      if (!boolOrOp_0()
       && !next("||")
         ) return reject();
      __();
      sem.C();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  boolOrOp_0 = "or" NLOD
  //-------------------------------------------------------------------
  public boolean boolOrOp_0()
    {
      begin("");
      if (!next("or")) return rejectInner();
      if (!NLOD()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  boolAndExpr = setExpr (boolAndOp setExpr)* {TL} ;
  //=====================================================================
  public boolean boolAndExpr()
    {
      begin("boolAndExpr");
      if (!setExpr()) return reject();
      while (boolAndExpr_0());
      sem.TL();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  boolAndExpr_0 = boolAndOp setExpr
  //-------------------------------------------------------------------
  public boolean boolAndExpr_0()
    {
      begin("");
      if (!boolAndOp()) return rejectInner();
      if (!setExpr()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  boolAndOp = ("and" NLOD / "&&") __ {C} ;
  //=====================================================================
  public boolean boolAndOp()
    {
      begin("boolAndOp");
      if (!boolAndOp_0()
       && !next("&&")
         ) return reject();
      __();
      sem.C();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  boolAndOp_0 = "and" NLOD
  //-------------------------------------------------------------------
  public boolean boolAndOp_0()
    {
      begin("");
      if (!next("and")) return rejectInner();
      if (!NLOD()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  setExpr = comparisonExpr (setOp comparisonExpr)* {TL} ;
  //=====================================================================
  public boolean setExpr()
    {
      begin("setExpr");
      if (!comparisonExpr()) return reject();
      while (setExpr_0());
      sem.TL();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  setExpr_0 = setOp comparisonExpr
  //-------------------------------------------------------------------
  public boolean setExpr_0()
    {
      begin("");
      if (!setOp()) return rejectInner();
      if (!comparisonExpr()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  setOp = ("union" NLOD / "|") __ {C} ;
  //=====================================================================
  public boolean setOp()
    {
      begin("setOp");
      if (!setOp_0()
       && !next('|')
         ) return reject();
      __();
      sem.C();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  setOp_0 = "union" NLOD
  //-------------------------------------------------------------------
  public boolean setOp_0()
    {
      begin("");
      if (!next("union")) return rejectInner();
      if (!NLOD()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  comparisonExpr = simpleExpr (cmpOp simpleExpr)? {TL} ;
  //=====================================================================
  public boolean comparisonExpr()
    {
      begin("comparisonExpr");
      if (!simpleExpr()) return reject();
      comparisonExpr_0();
      sem.TL();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  comparisonExpr_0 = cmpOp simpleExpr
  //-------------------------------------------------------------------
  public boolean comparisonExpr_0()
    {
      begin("");
      if (!cmpOp()) return rejectInner();
      if (!simpleExpr()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  cmpOp = ("==" / "!=" / "<" ![=] / ">" ![=] / "<=" / ">=") __ {C} ;
  //=====================================================================
  public boolean cmpOp()
    {
      begin("cmpOp");
      if (!next("==")
       && !next("!=")
       && !cmpOp_0()
       && !cmpOp_1()
       && !next("<=")
       && !next(">=")
         ) return reject();
      __();
      sem.C();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  cmpOp_0 = "<" ![=]
  //-------------------------------------------------------------------
  public boolean cmpOp_0()
    {
      begin("");
      if (!next('<')) return rejectInner();
      if (!aheadNot('=')) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  cmpOp_1 = ">" ![=]
  //-------------------------------------------------------------------
  public boolean cmpOp_1()
    {
      begin("");
      if (!next('>')) return rejectInner();
      if (!aheadNot('=')) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  simpleExpr = (val / path) {TL} ;
  //=====================================================================
  public boolean simpleExpr()
    {
      begin("simpleExpr");
      if (!val()
       && !path()
         ) return reject();
      sem.TL();
      return accept();
    }
  
  //=====================================================================
  //  funcCall = name "(" __ (expr ("," __ expr)*)? ")" __ {TL} ;
  //=====================================================================
  public boolean funcCall()
    {
      begin("funcCall");
      if (!name()) return reject();
      if (!next('(')) return reject();
      __();
      funcCall_0();
      if (!next(')')) return reject();
      __();
      sem.TL();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  funcCall_0 = expr ("," __ expr)*
  //-------------------------------------------------------------------
  public boolean funcCall_0()
    {
      begin("");
      if (!expr()) return rejectInner();
      while (funcCall_1());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  funcCall_1 = "," __ expr
  //-------------------------------------------------------------------
  public boolean funcCall_1()
    {
      begin("");
      if (!next(',')) return rejectInner();
      __();
      if (!expr()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  val = StringLiteral {CS} / Literal {C} ;
  //=====================================================================
  public boolean val()
    {
      begin("val");
      if (StringLiteral())
      { sem.CS(); return accept(); }
      if (Literal())
      { sem.C(); return accept(); }
      return reject();
    }
  
  //=====================================================================
  //  path = (descendants relativePath / relativePath) {TL} ;
  //=====================================================================
  public boolean path()
    {
      begin("path");
      if (!path_0()
       && !relativePath()
         ) return reject();
      sem.TL();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  path_0 = descendants relativePath
  //-------------------------------------------------------------------
  public boolean path_0()
    {
      begin("");
      if (!descendants()) return rejectInner();
      if (!relativePath()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  relativePath = step ((descendants / "." __) step)* descendants?
  //    {TL} ;
  //=====================================================================
  public boolean relativePath()
    {
      begin("relativePath");
      if (!step()) return reject();
      while (relativePath_0());
      descendants();
      sem.TL();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  relativePath_0 = (descendants / "." __) step
  //-------------------------------------------------------------------
  public boolean relativePath_0()
    {
      begin("");
      if (!descendants()
       && !relativePath_1()
         ) return rejectInner();
      if (!step()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  relativePath_1 = "." __
  //-------------------------------------------------------------------
  public boolean relativePath_1()
    {
      begin("");
      if (!next('.')) return rejectInner();
      __();
      return acceptInner();
    }
  
  //=====================================================================
  //  descendants = ".." {C} ;
  //=====================================================================
  public boolean descendants()
    {
      begin("descendants");
      if (!next("..")) return reject();
      sem.C();
      return accept();
    }
  
  //=====================================================================
  //  step = selection varMatch? filter? regexMatch? {T} ;
  //=====================================================================
  public boolean step()
    {
      begin("step");
      if (!selection()) return reject();
      varMatch();
      filter();
      regexMatch();
      sem.T();
      return accept();
    }
  
  //=====================================================================
  //  selection = (current / funcCall / property / children / selector /
  //    var / "(" __ expr ")" __) subscript? {T} ;
  //=====================================================================
  public boolean selection()
    {
      begin("selection");
      if (!current()
       && !funcCall()
       && !property()
       && !children()
       && !selector()
       && !var()
       && !selection_0()
         ) return reject();
      subscript();
      sem.T();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  selection_0 = "(" __ expr ")" __
  //-------------------------------------------------------------------
  public boolean selection_0()
    {
      begin("");
      if (!next('(')) return rejectInner();
      __();
      if (!expr()) return rejectInner();
      if (!next(')')) return rejectInner();
      __();
      return acceptInner();
    }
  
  //=====================================================================
  //  current = "_" NLOD __ {T} ;
  //=====================================================================
  public boolean current()
    {
      begin("current");
      if (!next('_')) return reject();
      if (!NLOD()) return reject();
      __();
      sem.T();
      return accept();
    }
  
  //=====================================================================
  //  property = ("@" name / (namespace ":")? name) {C} ;
  //=====================================================================
  public boolean property()
    {
      begin("property");
      if (!property_0()
       && !property_1()
         ) return reject();
      sem.C();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  property_0 = "@" name
  //-------------------------------------------------------------------
  public boolean property_0()
    {
      begin("");
      if (!next('@')) return rejectInner();
      if (!name()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  property_1 = (namespace ":")? name
  //-------------------------------------------------------------------
  public boolean property_1()
    {
      begin("");
      property_2();
      if (!name()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  property_2 = namespace ":"
  //-------------------------------------------------------------------
  public boolean property_2()
    {
      begin("");
      if (!namespace()) return rejectInner();
      if (!next(':')) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  namespace = Identifier {C} ;
  //=====================================================================
  public boolean namespace()
    {
      begin("namespace");
      if (!Identifier()) return reject();
      sem.C();
      return accept();
    }
  
  //=====================================================================
  //  name = Identifier {C} ;
  //=====================================================================
  public boolean name()
    {
      begin("name");
      if (!Identifier()) return reject();
      sem.C();
      return accept();
    }
  
  //=====================================================================
  //  children = "*" __ {C} ;
  //=====================================================================
  public boolean children()
    {
      begin("children");
      if (!next('*')) return reject();
      __();
      sem.C();
      return accept();
    }
  
  //=====================================================================
  //  selector = "ยง" __ {C} ;
  //=====================================================================
  public boolean selector()
    {
      begin("selector");
      if (!next('\u00a7')) return reject();
      __();
      sem.C();
      return accept();
    }
  
  //=====================================================================
  //  regexMatch = "~" __ simpleExpr ("groups" __ group ("," __ group)*)?
  //    {TL} ;
  //=====================================================================
  public boolean regexMatch()
    {
      begin("regexMatch");
      if (!next('~')) return reject();
      __();
      if (!simpleExpr()) return reject();
      regexMatch_0();
      sem.TL();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  regexMatch_0 = "groups" __ group ("," __ group)*
  //-------------------------------------------------------------------
  public boolean regexMatch_0()
    {
      begin("");
      if (!next("groups")) return rejectInner();
      __();
      if (!group()) return rejectInner();
      while (regexMatch_1());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  regexMatch_1 = "," __ group
  //-------------------------------------------------------------------
  public boolean regexMatch_1()
    {
      begin("");
      if (!next(',')) return rejectInner();
      __();
      if (!group()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  group = (varMatch / simpleExpr) {T} ;
  //=====================================================================
  public boolean group()
    {
      begin("group");
      if (!varMatch()
       && !simpleExpr()
         ) return reject();
      sem.T();
      return accept();
    }
  
  //=====================================================================
  //  subscript = (sequenceSubscript / arraySubscript) {T} ;
  //=====================================================================
  public boolean subscript()
    {
      begin("subscript");
      if (!sequenceSubscript()
       && !arraySubscript()
         ) return reject();
      sem.T();
      return accept();
    }
  
  //=====================================================================
  //  sequenceSubscript = "[:" __ (IntegerLiteral / "*" __) ":]" __ {C}
  //    ;
  //=====================================================================
  public boolean sequenceSubscript()
    {
      begin("sequenceSubscript");
      if (!next("[:")) return reject();
      __();
      if (!IntegerLiteral()
       && !sequenceSubscript_0()
         ) return reject();
      if (!next(":]")) return reject();
      __();
      sem.C();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  sequenceSubscript_0 = "*" __
  //-------------------------------------------------------------------
  public boolean sequenceSubscript_0()
    {
      begin("");
      if (!next('*')) return rejectInner();
      __();
      return acceptInner();
    }
  
  //=====================================================================
  //  arraySubscript = "[" __ (IntegerLiteral / "*" __) "]" __ {C} ;
  //=====================================================================
  public boolean arraySubscript()
    {
      begin("arraySubscript");
      if (!next('[')) return reject();
      __();
      if (!IntegerLiteral()
       && !sequenceSubscript_0()
         ) return reject();
      if (!next(']')) return reject();
      __();
      sem.C();
      return accept();
    }
  
  //=====================================================================
  //  filter = "?" __ "(" __ expr ")" __ {T} ;
  //=====================================================================
  public boolean filter()
    {
      begin("filter");
      if (!next('?')) return reject();
      __();
      if (!next('(')) return reject();
      __();
      if (!expr()) return reject();
      if (!next(')')) return reject();
      __();
      sem.T();
      return accept();
    }
  
  //=====================================================================
  //  varMatch = var {T} ;
  //=====================================================================
  public boolean varMatch()
    {
      begin("varMatch");
      if (!var()) return reject();
      sem.T();
      return accept();
    }
  
  //=====================================================================
  //  var = "$" Identifier? __ {C} ;
  //=====================================================================
  public boolean var()
    {
      begin("var");
      if (!next('$')) return reject();
      Identifier();
      __();
      sem.C();
      return accept();
    }
  
  //=====================================================================
  //  NLOD = !LetterOrDigit ;
  //=====================================================================
  public boolean NLOD()
    {
      begin("NLOD");
      if (!NLOD_0()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  NLOD_0 = !LetterOrDigit
  //-------------------------------------------------------------------
  public boolean NLOD_0()
    {
      begin("","not LetterOrDigit");
      if (LetterOrDigit()) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  __ = ([ \t\r\n\f]+ / "//" _*+ ([\r\n] / !_))* ;
  //=====================================================================
  public boolean __()
    {
      begin("__");
      while (___0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  ___0 = [ \t\r\n\f]+ / "//" _*+ ([\r\n] / !_)
  //-------------------------------------------------------------------
  public boolean ___0()
    {
      begin("");
      if (___1()) return acceptInner();
      if (___2()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  ___1 = [ \t\r\n\f]+
  //-------------------------------------------------------------------
  public boolean ___1()
    {
      begin("");
      if (!nextIn(" \t\r\n\f")) return rejectInner();
      while (nextIn(" \t\r\n\f"));
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ___2 = "//" _*+ ([\r\n] / !_)
  //-------------------------------------------------------------------
  public boolean ___2()
    {
      begin("");
      if (!next("//")) return rejectInner();
      while (!___3())
        if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  ___3 = [\r\n] / !_
  //-------------------------------------------------------------------
  public boolean ___3()
    {
      begin("");
      if (nextIn("\r\n")) return acceptInner();
      if (___4()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  ___4 = !_
  //-------------------------------------------------------------------
  public boolean ___4()
    {
      begin("","end of text");
      if (next()) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  Identifier = !Keyword (Letter / AEscape) (LetterOrDigit / AEscape)*
  //    __ ;
  //=====================================================================
  public boolean Identifier()
    {
      begin("Identifier");
      if (!Identifier_0()) return reject();
      if (!Letter()
       && !AEscape()
         ) return reject();
      while (Identifier_1());
      __();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Identifier_0 = !Keyword
  //-------------------------------------------------------------------
  public boolean Identifier_0()
    {
      begin("","not Keyword");
      if (Keyword()) return rejectPred();
      return acceptPred();
    }
  
  //-------------------------------------------------------------------
  //  Identifier_1 = LetterOrDigit / AEscape
  //-------------------------------------------------------------------
  public boolean Identifier_1()
    {
      begin("");
      if (LetterOrDigit()) return acceptInner();
      if (AEscape()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  Letter = [a-z] / [A-Z] ;
  //=====================================================================
  public boolean Letter()
    {
      begin("Letter");
      if (nextIn('a','z')) return accept();
      if (nextIn('A','Z')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  LetterOrDigit = [a-z] / [A-Z] / [0-9] / [_] ;
  //=====================================================================
  public boolean LetterOrDigit()
    {
      begin("LetterOrDigit");
      if (nextIn('a','z')) return accept();
      if (nextIn('A','Z')) return accept();
      if (nextIn('0','9')) return accept();
      if (next('_')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  AEscape = "\" _ ;
  //=====================================================================
  public boolean AEscape()
    {
      begin("AEscape");
      if (!next('\\')) return reject();
      if (!next()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Keyword = ("true" / "false" / "null" / "and" / "or" / "union" /
  //    "this" / "if" / "then" / "else" / "groups") !LetterOrDigit ;
  //=====================================================================
  public boolean Keyword()
    {
      begin("Keyword");
      if (!next("true")
       && !next("false")
       && !next("null")
       && !next("and")
       && !next("or")
       && !next("union")
       && !next("this")
       && !next("if")
       && !next("then")
       && !next("else")
       && !next("groups")
         ) return reject();
      if (!NLOD_0()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  TRUE = "true" !LetterOrDigit __ ;
  //=====================================================================
  public boolean TRUE()
    {
      begin("TRUE");
      if (!next("true")) return reject();
      if (!NLOD_0()) return reject();
      __();
      return accept();
    }
  
  //=====================================================================
  //  FALSE = "false" !LetterOrDigit __ ;
  //=====================================================================
  public boolean FALSE()
    {
      begin("FALSE");
      if (!next("false")) return reject();
      if (!NLOD_0()) return reject();
      __();
      return accept();
    }
  
  //=====================================================================
  //  NULL = "null" !LetterOrDigit __ ;
  //=====================================================================
  public boolean NULL()
    {
      begin("NULL");
      if (!next("null")) return reject();
      if (!NLOD_0()) return reject();
      __();
      return accept();
    }
  
  //=====================================================================
  //  Literal = FloatLiteral / IntegerLiteral / BooleanLiteral /
  //    StringLiteral / NullLiteral ;
  //=====================================================================
  public boolean Literal()
    {
      begin("Literal");
      if (FloatLiteral()) return accept();
      if (IntegerLiteral()) return accept();
      if (BooleanLiteral()) return accept();
      if (StringLiteral()) return accept();
      if (NullLiteral()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  IntegerLiteral = (HexNumeral / BinaryNumeral / OctalNumeral /
  //    DecimalNumeral) [lL]? __ ;
  //=====================================================================
  public boolean IntegerLiteral()
    {
      begin("IntegerLiteral");
      if (!HexNumeral()
       && !BinaryNumeral()
       && !OctalNumeral()
       && !DecimalNumeral()
         ) return reject();
      nextIn("lL");
      __();
      return accept();
    }
  
  //=====================================================================
  //  DecimalNumeral = "0" / [1-9] ([_]* [0-9])* ;
  //=====================================================================
  public boolean DecimalNumeral()
    {
      begin("DecimalNumeral");
      if (next('0')) return accept();
      if (DecimalNumeral_0()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  DecimalNumeral_0 = [1-9] ([_]* [0-9])*
  //-------------------------------------------------------------------
  public boolean DecimalNumeral_0()
    {
      begin("");
      if (!nextIn('1','9')) return rejectInner();
      while (DecimalNumeral_1());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DecimalNumeral_1 = [_]* [0-9]
  //-------------------------------------------------------------------
  public boolean DecimalNumeral_1()
    {
      begin("");
      while (next('_'));
      if (!nextIn('0','9')) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  HexNumeral = ("0x" / "0X") HexDigits ;
  //=====================================================================
  public boolean HexNumeral()
    {
      begin("HexNumeral");
      if (!next("0x")
       && !next("0X")
         ) return reject();
      if (!HexDigits()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  OctalNumeral = "0" ([_]* [0-7])+ ;
  //=====================================================================
  public boolean OctalNumeral()
    {
      begin("OctalNumeral");
      if (!next('0')) return reject();
      if (!OctalNumeral_0()) return reject();
      while (OctalNumeral_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  OctalNumeral_0 = [_]* [0-7]
  //-------------------------------------------------------------------
  public boolean OctalNumeral_0()
    {
      begin("");
      while (next('_'));
      if (!nextIn('0','7')) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  BinaryNumeral = ("0b" / "0B") [01] ([_]* [01])* ;
  //=====================================================================
  public boolean BinaryNumeral()
    {
      begin("BinaryNumeral");
      if (!next("0b")
       && !next("0B")
         ) return reject();
      if (!nextIn("01")) return reject();
      while (BinaryNumeral_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  BinaryNumeral_0 = [_]* [01]
  //-------------------------------------------------------------------
  public boolean BinaryNumeral_0()
    {
      begin("");
      while (next('_'));
      if (!nextIn("01")) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  FloatLiteral = (HexadecimalFloatingPointLiteral /
  //    DecimalFloatingPointLiteral) __ ;
  //=====================================================================
  public boolean FloatLiteral()
    {
      begin("FloatLiteral");
      if (!HexadecimalFloatingPointLiteral()
       && !DecimalFloatingPointLiteral()
         ) return reject();
      __();
      return accept();
    }
  
  //=====================================================================
  //  DecimalFloatingPointLiteral = Digits "." Digits? Exponent? [fFdD]?
  //    / "." Digits Exponent? [fFdD]? / Digits Exponent [fFdD]? / Digits
  //    Exponent? [fFdD] ;
  //=====================================================================
  public boolean DecimalFloatingPointLiteral()
    {
      begin("DecimalFloatingPointLiteral");
      if (DecimalFloatingPointLiteral_0()) return accept();
      if (DecimalFloatingPointLiteral_1()) return accept();
      if (DecimalFloatingPointLiteral_2()) return accept();
      if (DecimalFloatingPointLiteral_3()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  DecimalFloatingPointLiteral_0 = Digits "." Digits? Exponent?
  //    [fFdD]?
  //-------------------------------------------------------------------
  public boolean DecimalFloatingPointLiteral_0()
    {
      begin("");
      if (!Digits()) return rejectInner();
      if (!next('.')) return rejectInner();
      Digits();
      Exponent();
      nextIn("fFdD");
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DecimalFloatingPointLiteral_1 = "." Digits Exponent? [fFdD]?
  //-------------------------------------------------------------------
  public boolean DecimalFloatingPointLiteral_1()
    {
      begin("");
      if (!next('.')) return rejectInner();
      if (!Digits()) return rejectInner();
      Exponent();
      nextIn("fFdD");
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DecimalFloatingPointLiteral_2 = Digits Exponent [fFdD]?
  //-------------------------------------------------------------------
  public boolean DecimalFloatingPointLiteral_2()
    {
      begin("");
      if (!Digits()) return rejectInner();
      if (!Exponent()) return rejectInner();
      nextIn("fFdD");
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DecimalFloatingPointLiteral_3 = Digits Exponent? [fFdD]
  //-------------------------------------------------------------------
  public boolean DecimalFloatingPointLiteral_3()
    {
      begin("");
      if (!Digits()) return rejectInner();
      Exponent();
      if (!nextIn("fFdD")) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Exponent = [eE] [+-]? Digits ;
  //=====================================================================
  public boolean Exponent()
    {
      begin("Exponent");
      if (!nextIn("eE")) return reject();
      nextIn("+-");
      if (!Digits()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  HexadecimalFloatingPointLiteral = HexSignificand BinaryExponent
  //    [fFdD]? ;
  //=====================================================================
  public boolean HexadecimalFloatingPointLiteral()
    {
      begin("HexadecimalFloatingPointLiteral");
      if (!HexSignificand()) return reject();
      if (!BinaryExponent()) return reject();
      nextIn("fFdD");
      return accept();
    }
  
  //=====================================================================
  //  HexSignificand = ("0x" / "0X") HexDigits? "." HexDigits /
  //    HexNumeral "."? ;
  //=====================================================================
  public boolean HexSignificand()
    {
      begin("HexSignificand");
      if (HexSignificand_0()) return accept();
      if (HexSignificand_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  HexSignificand_0 = ("0x" / "0X") HexDigits? "." HexDigits
  //-------------------------------------------------------------------
  public boolean HexSignificand_0()
    {
      begin("");
      if (!next("0x")
       && !next("0X")
         ) return rejectInner();
      HexDigits();
      if (!next('.')) return rejectInner();
      if (!HexDigits()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  HexSignificand_1 = HexNumeral "."?
  //-------------------------------------------------------------------
  public boolean HexSignificand_1()
    {
      begin("");
      if (!HexNumeral()) return rejectInner();
      next('.');
      return acceptInner();
    }
  
  //=====================================================================
  //  HexDigits = HexDigit ([_]* HexDigit)* ;
  //=====================================================================
  public boolean HexDigits()
    {
      begin("HexDigits");
      if (!HexDigit()) return reject();
      while (HexDigits_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  HexDigits_0 = [_]* HexDigit
  //-------------------------------------------------------------------
  public boolean HexDigits_0()
    {
      begin("");
      while (next('_'));
      if (!HexDigit()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  HexDigit = [a-f] / [A-F] / [0-9] ;
  //=====================================================================
  public boolean HexDigit()
    {
      begin("HexDigit");
      if (nextIn('a','f')) return accept();
      if (nextIn('A','F')) return accept();
      if (nextIn('0','9')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  BinaryExponent = [pP] [+-]? Digits ;
  //=====================================================================
  public boolean BinaryExponent()
    {
      begin("BinaryExponent");
      if (!nextIn("pP")) return reject();
      nextIn("+-");
      if (!Digits()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Digits = [0-9] ([_]* [0-9])* ;
  //=====================================================================
  public boolean Digits()
    {
      begin("Digits");
      if (!nextIn('0','9')) return reject();
      while (DecimalNumeral_1());
      return accept();
    }
  
  //=====================================================================
  //  BooleanLiteral = TRUE / FALSE ;
  //=====================================================================
  public boolean BooleanLiteral()
    {
      begin("BooleanLiteral");
      if (TRUE()) return accept();
      if (FALSE()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  StringLiteral = "'" (Escape / !['\\n\r] _)* "'" __ ;
  //=====================================================================
  public boolean StringLiteral()
    {
      begin("StringLiteral");
      if (!next('\'')) return reject();
      while (StringLiteral_0());
      if (!next('\'')) return reject();
      __();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  StringLiteral_0 = Escape / !['\\n\r] _
  //-------------------------------------------------------------------
  public boolean StringLiteral_0()
    {
      begin("");
      if (Escape()) return acceptInner();
      if (StringLiteral_1()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  StringLiteral_1 = !['\\n\r] _
  //-------------------------------------------------------------------
  public boolean StringLiteral_1()
    {
      begin("");
      if (!aheadNotIn("'\\\n\r")) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Escape = "\" (![u0-7] / OctalEscape / UnicodeEscape) ;
  //=====================================================================
  public boolean Escape()
    {
      begin("Escape");
      if (!next('\\')) return reject();
      if (!Escape_0()
       && !OctalEscape()
       && !UnicodeEscape()
         ) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Escape_0 = ![u0-7]
  //-------------------------------------------------------------------
  public boolean Escape_0()
    {
      begin("","not [u0-7]");
      if (nextIn("u0-7")) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  OctalEscape = [0-3] [0-7] [0-7] / [0-7] [0-7] / [0-7] ;
  //=====================================================================
  public boolean OctalEscape()
    {
      begin("OctalEscape");
      if (OctalEscape_0()) return accept();
      if (OctalEscape_1()) return accept();
      if (nextIn('0','7')) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  OctalEscape_0 = [0-3] [0-7] [0-7]
  //-------------------------------------------------------------------
  public boolean OctalEscape_0()
    {
      begin("");
      if (!nextIn('0','3')) return rejectInner();
      if (!nextIn('0','7')) return rejectInner();
      if (!nextIn('0','7')) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  OctalEscape_1 = [0-7] [0-7]
  //-------------------------------------------------------------------
  public boolean OctalEscape_1()
    {
      begin("");
      if (!nextIn('0','7')) return rejectInner();
      if (!nextIn('0','7')) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  UnicodeEscape = "u"+ HexDigit HexDigit HexDigit HexDigit ;
  //=====================================================================
  public boolean UnicodeEscape()
    {
      begin("UnicodeEscape");
      if (!next('u')) return reject();
      while (next('u'));
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      if (!HexDigit()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  NullLiteral = NULL ;
  //=====================================================================
  public boolean NullLiteral()
    {
      begin("NullLiteral");
      if (!NULL()) return reject();
      return accept();
    }
  
}
